import { Position3Matrix, Vec3Array } from "Math/Types/Math.types";
declare class V3 {
    _data: Vec3Array;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get z(): number;
    set z(z: number);
}
export declare class Vector3 extends V3 {
    static Zero: Vector3;
    static Top: Vector3;
    static Bottom: Vector3;
    static East: Vector3;
    static West: Vector3;
    static North: Vector3;
    static South: Vector3;
    _tv3: V3;
    static NaNRestore(vec3: Position3Matrix): void;
    constructor(x?: number, y?: number, z?: number);
    updateFromArray(array: number[] | Float32Array | Float64Array, startIndex?: number): this;
    set(x: number, y: number, z: number): this;
    setAll(value: number): this;
    updateFromVec3(vector: Vector3): this;
    roundVector(deciamlPoints?: number): this;
    translate(x: number, y: number, z: number): this;
    getTranslated(x: number, y: number, z: number): V3;
    scaleXYZ(scaler: number): this;
    scale(xScale: number, yScale: number, zScale: number): this;
    getScaledXYZ(scaler: number): V3;
    getScaled(xScale: number, yScale: number, zScale: number): V3;
    add(x: number, y: number, z: number): this;
    addXYZ(add: number): this;
    addFromVec3(vector: Vector3): this;
    isZero(): boolean;
    subtractXYZ(subtract: number): this;
    subtractFromObj(vector: Vector3): this;
    getAddXYZ(add: number): V3;
    getSubtractXYZ(subtract: number): V3;
    addVector(vector3: Vector3): this;
    getAddedVector(vector3: Vector3): V3;
    subtractVector(vector3: Vector3): this;
    getSubtractedVector(vector3: Vector3): V3;
    scaleVector(vector3: Vector3): this;
    getScaledVector(vector3: Vector3): V3;
    getLength(): number;
    divide(scalar: number): this;
    getDivided(scalar: number): V3;
    normalize(): this;
    isEqual(vector3: Vector3): boolean;
    isNotEqual(vector3: Vector3): boolean;
}
export {};
